#!/usr/bin/perl

use strict;
use warnings;
use LWP::UserAgent;
use JSON;
use Net::IP;

## CONFIGURATION ##
###################

my $url         = "http://hannover.freifunk.net:8079/nodes.json";

## END OF CONFIGURATION ##
##########################

sub normalize_nodename {
    my $data = $_[0] || "";

    $data = lc( $data );        # lower-case
    $data =~ s/[^a-z0-9\-]/-/g; # only alphanumeric and dashes
    $data =~ s/[\-]+/-/g;       # no subsequent dashes
    $data =~ s/^[\-]//g;        # no leading dashes
    
    return $data;
}
# Shamelessly stolen from https://prog-snippets.blogspot.de/2008/04/convert-ipv6-address-to-ipv6-ptr-record.html
sub co_cidr_to_ptr_ipv6
{
    # Convert: IPv6 address to IPv6 PTR
    # 12:34::a8 -> 8.a.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.4.3.0.0.2.0.0.0.ip6.arpa
    #
    my ($pData) = @_;
    my ($first_part,$last_part) = split "::",$pData;

    my ($sz1,$f_indot) = co_conv2dot($first_part,);
    my ($sz2,$s_indot) = co_conv2dot($last_part);

    my $tot_sz = $sz1 + $sz2;

    my $ipv6_arpa = $f_indot."."."ip6.arpa";

    my $rem= 8 - $tot_sz;

    for (my $c =0; $c<$rem;$c++)
    {
    $ipv6_arpa = "0.0.0.0".".".$ipv6_arpa;
    }

    my $op_ipv6_format = $s_indot.".".$ipv6_arpa;

    #print "Return Value: $op_ipv6_format\n";
    return $op_ipv6_format;
}

sub co_conv2dot
{
    # sub routine call for cidr_to_ptr_ipv6
    # Help covert IPv6 address to PTR IPv6 only
    #
    #
    my $part = shift;

    my @hex_arr = split ":",$part;
    my @reverse =reverse@hex_arr;

    my $cnt;

    my @ipv6_arr;

    foreach (@reverse)
    {
    $_ = reverse $_; ## 43 then 21
    my @octs = split //,$_;
    my $ip_for = $octs[0];
    my $i;
    for ($i =1;$i<@octs;$i++)
    {
    $ip_for = $ip_for.".".$octs[$i];
    }
    while($i<4)
    {
    $ip_for = $ip_for.".".0;
    $i++;
    }
    push @ipv6_arr, $ip_for;
    }

    my $ipv6_arpa = $ipv6_arr[0];

    for (my $i =1;$i<@ipv6_arr;$i++)
    {
    $ipv6_arpa = $ipv6_arpa.".".$ipv6_arr[$i];
    }

    $cnt = @ipv6_arr;
    return ($cnt,$ipv6_arpa);
}


my $ua = LWP::UserAgent->new;
$ua->timeout(10);

my $mode = $ARGV[0];
my $domain = $ARGV[1];

if ($mode eq "forward")
{
print '$TTL 4h'."\n";
print '@           IN  SOA     ns1.ffh.    zonemaster.ffh.zone. ('."\n";
print '                ' . time() . '    ; serial'."\n";
print '                4h      ; slave refresh interval'."\n";
print '                1h      ; slave retry interval'."\n";
print '                2w      ; slave copy expire time'."\n";
print '                1h      ; NXDOMAIN cache time'."\n";
print '                )'."\n";
print ''."\n";
}
else
{
print '@   IN  SOA ansibletest.tbspace.de. admin.example.com. ('."\n";
print '    ' . time() . '  ; serial'."\n";
print '    1h      ; slave refresh interval'."\n";
print '    15m     ; slave retry interval'."\n";
print '    1w      ; slave copy expire time'."\n";
print '    1h      ; NXDOMAIN cache time'."\n";
print '    )'."\n";
print ''."\n";
print '@   IN  NS  ansibletest.tbspace.de.'."\n";
print '@   IN  NS  ns2.he.net.'."\n";
print '@   IN  NS  ns3.he.net.'."\n";
}
my $response = $ua->get( $url );
if ($response->is_success) {

    my @output;
   
    my $json = $response->decoded_content();
    my $data = from_json( $json, { utf8  => 1 } );

    # Get hostname and IPv6 address from nodes.json
    # normalize hostname
    foreach my $node_id ( keys %{ $data->{nodes} } ) {
        my $ip;
        my $names;
        foreach my $node_ip ( @{ $data->{nodes}->{$node_id}->{nodeinfo}->{network}->{addresses} } ) {
            next if $node_ip !~ m/^fdca/;
            $ip = $node_ip; 
        }
        next unless $ip;
        my $hostname = normalize_nodename( $data->{nodes}->{$node_id}->{nodeinfo}->{hostname} );
        
        if ($mode eq "forward")
        {
            if ($hostname ne "")
            {
                push( @output, "$hostname.$domain. IN AAAA $ip\n" );
            }
        }
        else
        {
            if ($hostname ne "")
            {
                my $ip = new Net::IP ($ip) or die (Net::IP::Error());
                my $ptr = $ip->reverse_ip();
                push( @output, "$ptr IN PTR $hostname.$domain.\n" );
            }
        }
    }

    # Output a sorted list, so that git is not polluted with unnecessary changes
    foreach my $line ( sort( @output ) ) {
        print $line;
    }
}

1;
